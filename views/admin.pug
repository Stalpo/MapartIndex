doctype html
html
  - const pageTitle = "Administration"
  include includes/head.pug
  body
    include includes/navbar.pug
    div.container
      h1.text-center= pageTitle
      if !admin
        div.alert.alert-danger(role="alert")
          | You are not an administrator
      else
        form
          div.row
            div.col
              div.form-group
                label.sr-only(for='userSelector') Select User:
                div.input-group.mb-2.mr-sm-2
                  div.input-group-prepend
                    div.input-group-text User
                  select#userSelector.form-control
            div.col
              div.form-group
                label.sr-only(for='artistSelector') Select Artist:
                div.input-group.mb-2.mr-sm-2
                  div.input-group-prepend
                    div.input-group-text Artist
                  select#artistSelector.form-control
            div.col
              div.form-group
                label.sr-only(for='sortSelector') Sort By:
                div.input-group.mb-2.mr-sm-2
                  div.input-group-prepend
                    div.input-group-text Sort
                  select#sortSelector.form-control

        table.table.table-striped#mapsTable
          thead
            tr
              th Display Name
              th Created At
              th Username
              th Image
              th Artist
              th NSFW
              th Actions

          tbody(id='mapsTableBody')

        script.
          // Function to fetch data from the API
          async function fetchData(url) {
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error('Network response was not ok');
            }
            return response.json();
          }

          // Function to populate select element with options
          function populateSelect(selectorId, data) {
            const selector = document.getElementById(selectorId);
            selector.innerHTML = ''; // Clear previous options
            data.forEach(option => {
              const optionElement = document.createElement('option');
              optionElement.value = option.value; // Set the value of the option
              optionElement.textContent = option.label; // Set the text content of the option
              selector.appendChild(optionElement); // Append the option to the select element
            });
          }

          // Function to populate user selector
          async function populateUserSelector() {
            try {
              const uniqueUsernamesMapId = await fetchData('/mapId-info/uniqueUsernames');
              const uniqueUsernamesMapArt = await fetchData('/mapArt-info/uniqueUsernames');
              
              const combinedUniqueUsernames = [...new Set([...uniqueUsernamesMapId, ...uniqueUsernamesMapArt])];
              const userOptions = combinedUniqueUsernames.map(user => ({ value: user, label: user }));
              userOptions.unshift({ value: null, label: "All Users" });
              
              populateSelect('userSelector', userOptions);
            } catch (error) {
              console.error('Error fetching user data:', error);
            }
          }

          // Function to populate artist selector
          async function populateArtistSelector() {
            try {
              const uniqueArtistsMapId = await fetchData('/mapId-info/uniqueArtists');
              const uniqueArtistsMapArt = await fetchData('/mapArt-info/uniqueArtists');

              const combinedUniqueArtists = [...new Set([...uniqueArtistsMapId, ...uniqueArtistsMapArt])];
              const artistOptions = combinedUniqueArtists.map(artist => ({ value: artist, label: artist }));
              artistOptions.unshift({ value: null, label: "All Artists" });

              populateSelect('artistSelector', artistOptions);
            } catch (error) {
              console.error('Error fetching artist data:', error);
            }
          }

          async function populateSortSelector() {
            const sortSelector = document.getElementById('sortSelector');

            const options = [
              { value: 'nameAsc', label: 'Name (Ascending)' },
              { value: 'nameDesc', label: 'Name (Descending)' },
              { value: 'dateAsc', label: 'Date (Ascending)' },
              { value: 'dateDesc', label: 'Date (Descending)', selected: true }
            ];

            options.forEach(option => {
              const sortOption = document.createElement('option');
              sortOption.value = option.value;
              sortOption.textContent = option.label;
              if (option.selected) {
                sortOption.setAttribute('selected', true);
              }
              sortSelector.appendChild(sortOption);
            });
          }

          // Function to handle API call with updated parameters
          async function fetchMaps(page = 1, user = "", artist = "", sort = "dateDesc") {
            const perPage = 25;
            let mapIdUrl = `/api/mapId/maps?page=${page}&perPage=${perPage}&sort=${sort}`;
            let mapArtUrl = `/api/mapArt/maps?page=${page}&perPage=${perPage}&sort=${sort}`;

            // Construct user and artist parameters conditionally
            const userParam = (user && user !== "null") ? `&user=${user}` : "";
            const artistParam = (artist && artist !== "null") ? `&artist=${artist}` : "";

            // Append user and artist parameters to both URLs
            mapIdUrl += userParam + artistParam;
            mapArtUrl += userParam + artistParam;

            // Show loading spinner
            document.getElementById('loadingSpinner').style.display = 'block';

            try {
              // Make two separate API requests
              const [mapIdResponse, mapArtResponse] = await Promise.all([
                fetch(mapIdUrl),
                fetch(mapArtUrl)
              ]);

              // Check if both responses are OK
              if (!mapIdResponse.ok || !mapArtResponse.ok) {
                throw new Error('One or more network responses were not ok');
              }

              // Parse response data
              const mapIdData = await mapIdResponse.json();
              const mapArtData = await mapArtResponse.json();

              // Combine data into a unique array
              const combinedData = [...mapIdData, ...mapArtData];

              // Update the UI with the fetched maps
              buildTable(combinedData);
              console.log(combinedData);

              // Start observing intersection once grid is populated
              startObservingIntersection();
            } catch (error) {
              console.error('Error fetching map data:', error);
            } finally {
              // Hide loading spinner regardless of success or failure
              document.getElementById('loadingSpinner').style.display = 'none';
            }
          }

          // Function to handle input selector change events
          function handleSelectorChange() {
            const user = document.getElementById('userSelector').value;
            const artist = document.getElementById('artistSelector').value;
            const sort = document.getElementById('sortSelector').value;
            
            // Clear the grid before fetching new data
            clearGrid();

            fetchMaps(1, user, artist, sort);
          }

          // Function to clear the grid
          function clearGrid() {
            const gridContainer = document.getElementById('mapsTableBody');
            gridContainer.innerHTML = '';
          }

          // Attach event listeners to input selectors
          document.getElementById('userSelector').addEventListener('change', handleSelectorChange);
          document.getElementById('artistSelector').addEventListener('change', handleSelectorChange);
          document.getElementById('sortSelector').addEventListener('change', handleSelectorChange);

          // Function to build the table
          function buildTable(maps) {
            const tableBody = document.getElementById('mapsTableBody');

            // Build new rows
            maps.forEach(map => {
              const newRow = document.createElement('tr');
              newRow.className = 'vertical-center';

              const imgUrl = map.displayName.includes("MAPART") ? `/public/uploads/mapart/${map.imgUrl}` : `/public/uploads/${map.imgUrl}`;
              const viewUrl = map.displayName.includes("MAPART") ? `/mapArt/${map.id}` : `/mapId/${map.id}`;
              const editUrl = map.displayName.includes("MAPART") ? `/mapArt-edit/${map.id}` : `/mapId-edit/${map.id}`;
              const deleteUrl = map.displayName.includes("MAPART") ? `/deleteMapArt?mapId=${map.id}` : `/deleteMapId?mapId=${map.id}`;

              newRow.innerHTML = `
                <td>${map.displayName}</td>
                <td>${new Date(map.createdAt).toLocaleString('en-US')}</td>
                <td>${map.username}</td>
                <td><img src="${imgUrl}" alt="Map Image" style="max-width: 100px; max-height: 100px;"></td>
                <td>${map.artist}</td>
                <td>${map.nsfw}</td>
                <td>
                  <div class='btn-group' role='group' aria-label='Buttons'>
                    <button class='btn btn-primary' type='button' onclick="location.href='${viewUrl}'"><i class='fa fa-eye'></i></button>
                    <button class='btn btn-primary' type='button' onclick="location.href='${editUrl}'"><i class='fa fa-pencil-alt'></i></button>
                    <button class='btn btn-danger' type='button' onclick="location.href='${deleteUrl}'"><i class='fa fa-trash'></i></button>
                  </div>
                </td>
              `;
              tableBody.appendChild(newRow);
            });
          }

          // Lazy loading
          let observer;
          let currentPage = 1;
          let user = "";
          let artist = "";
          let sort = "dateDesc";

          function startObservingIntersection() {
            observer = new IntersectionObserver(entries => {
              if (entries[0].isIntersecting) {
                fetchNextPage();
              }
            }, {
              root: null,
              rootMargin: '0px',
              threshold: 1.0
            });

            const lastGridElement = document.getElementById('mapsTableBody').lastElementChild;
            observer.observe(lastGridElement);
          }

          async function fetchNextPage() {
            currentPage++;
            sort = document.getElementById('sortSelector').value;
            const lastGridElement = document.getElementById('mapsTableBody').lastElementChild;
            observer.unobserve(lastGridElement);
            fetchMaps(currentPage, user, artist, sort);
          }

          // Call the function to populate selectors and fetch initial data when the page loads
          document.addEventListener('DOMContentLoaded', () => {
            populateUserSelector();
            populateArtistSelector();
            populateSortSelector();
            // Initial API call on page load
            fetchMaps();
          });

        // Grid container for images
        div#gridContainer.row.mb-4

        // Keep loadingSpinner at bottom of page
        script.
          function createLoadingSpinner() {
            const loadingSpinner = document.createElement('div');
            loadingSpinner.id = 'loadingSpinner';
            loadingSpinner.className = 'text-center mt-4';
            
            const spinnerIcon = document.createElement('i');
            spinnerIcon.className = 'fa fa-spinner fa-spin fa-3x';
            
            const loadingText = document.createElement('p');
            loadingText.textContent = 'Loading...';
            
            loadingSpinner.appendChild(spinnerIcon);
            loadingSpinner.appendChild(loadingText);
            
            return loadingSpinner;
          }

          const container = document.querySelector('.container');
          const loadingSpinner = createLoadingSpinner();
          container.appendChild(loadingSpinner);

        style.
          .pixelated-image {
            image-rendering: pixelated;
          };

      include includes/scripts.pug