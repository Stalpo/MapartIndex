doctype html
html
  - const pageTitle = "Maps"
  include includes/head.pug
  body
    include includes/navbar.pug
    div.container
      h1.text-center= pageTitle
      hr
      div.row.justify-content-center
        div.col-auto
          button#toggleSelectorsButton.btn.btn-primary.btn-sm.mb-3 Filtering and Sorting
      form#selectorsForm(style={display: 'none'})
        div.row
          div.col
            select#userSelector.form-control(data-live-search='true')
          div.col
            select#artistSelector.form-control(data-live-search='true')
        br
        div.row
          div.col
            select#serverSelector.form-control(data-live-search='true')
          div.col
            select#sortSelector.form-control
          div.col
            select#viewSelector.form-control
              option(value='smallGrid' selected='true') Thumbnails
              option(value='grid') Cards
        hr

      script.
        // Function to fetch data from the API
        async function fetchData(url) {
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        }

        // Function to populate a select element and optionally set a default selection
        function populateSelect(selectId, options, defaultOption = "") {
          const select = document.getElementById(selectId);
          select.innerHTML = "";

          options.forEach(option => {
            const optElement = document.createElement("option");
            optElement.value = option;
            optElement.textContent = option;
            if (option === defaultOption) {
              optElement.selected = true;
            }
            select.appendChild(optElement);
          });
          $(`#${selectId}`).selectpicker('refresh');
        }

        // Function to populate user selector
        async function populateUserSelector() {
          try {
            const uniqueUsernames = await fetchData('/mapid/uniqueUsernames');
            uniqueUsernames.unshift("All Users");
            uniqueUsernames.sort();
            populateSelect('userSelector', uniqueUsernames, "All Users");
          } catch (error) {
            console.error('Error fetching user data:', error);
          }
        }

        // Function to populate artist selector
        async function populateArtistSelector() {
          try {
            const artistArray = await fetchData('/mapid/uniqueArtists');
            
            let uniqueArtists = artistArray.reduce((acc, artistString) => {
              return acc.concat(artistString.split(',').map(artist => artist.trim()).filter(artist => artist !== ''));
            }, []);

            uniqueArtists = [...new Set(uniqueArtists)];
            uniqueArtists.unshift("All Artists");
            uniqueArtists.sort();

            populateSelect('artistSelector', uniqueArtists, "All Artists");
          } catch (error) {
            console.error('Error fetching artist data:', error);
          }
        }

        // Function to populate server selector
        async function populateServerSelector() {
          try {
            const uniqueServers = await fetchData('/mapid/uniqueServers');
            uniqueServers.unshift("All Servers");
            uniqueServers.sort();
            populateSelect('serverSelector', uniqueServers, "All Servers");
          } catch (error) {
            console.error('Error fetching server data:', error);
          }
        }

        async function populateSortSelector() {
          const sortSelector = document.getElementById('sortSelector');

          const options = [
            { value: 'nameAsc', label: 'Name (Ascending)' },
            { value: 'nameDesc', label: 'Name (Descending)' },
            { value: 'dateAsc', label: 'Date (Ascending)' },
            { value: 'dateDesc', label: 'Date (Descending)', selected: true }
          ];

          options.forEach(option => {
            const sortOption = document.createElement('option');
            sortOption.value = option.value;
            sortOption.textContent = option.label;
            if (option.selected) {
              sortOption.setAttribute('selected', true);
            }
            sortSelector.appendChild(sortOption);
          });
          $(sortSelector).selectpicker('refresh');
        }

        // Function to handle API call with updated parameters
        async function fetchMaps(page = 1, user = "", artist = "", sort = "dateDesc", view, server) {
          const perPage = 25;
          let url = `/api/mapId/maps?page=${page}&perPage=${perPage}&sort=${sort}`;
          // Construct URL based on selected values
          if (user && user !== "All Users") {
            url += `&user=${user}`;
          }
          if (artist && artist !== "All Artists") {
            url += `&artist=${artist}`;
          }
          if (server && server !== "All Servers") {
            url += `&server=${server}`;
          }

          // Show loading spinner
          document.getElementById('loadingSpinner').style.display = 'block';

          try {
            const response = await fetch(url);
            if (!response.ok) {
              if (response.status === 404) {
                console.error('Likely last page of results');
              } else {
                throw new Error('Network response was not ok');
              }
            }
            const data = await response.json();
            
            // Based on the selected view type
            // Update the grid from response
            switch (view) {
              case 'smallGrid':
                buildSmallGrid(data);
                break;
              case 'grid':
                buildGrid(data);
                break;
              default:
                buildSmallGrid(data);
                break;
            }

            // Start observing intersection once grid is populated
            startObservingIntersection();
          } catch (error) {
            console.error('Error fetching map data:', error);
          } finally {
            // Hide loading spinner regardless of success or failure
            document.getElementById('loadingSpinner').style.display = 'none';
          }
        }

        // Function to handle selector and view selector change events
        function handleSelectorsChange() {
          currentPage = 1; // Reset currentPage to 1
          const user = document.getElementById('userSelector').value;
          const artist = document.getElementById('artistSelector').value;
          const sort = document.getElementById('sortSelector').value;
          const view = document.getElementById('viewSelector').value;
          const server = document.getElementById('serverSelector').value;

          // Clear the grid before fetching new data
          clearGrid();

          // Pass selected view type to fetchMaps
          fetchMaps(1, user, artist, sort, view, server);
        }

        // Function to clear the grid
        function clearGrid() {
          const gridContainer = document.getElementById('gridContainer');
          gridContainer.innerHTML = '';
        }

        // Attach event listeners to input selectors
        document.getElementById('userSelector').addEventListener('change', handleSelectorsChange);
        document.getElementById('artistSelector').addEventListener('change', handleSelectorsChange);
        document.getElementById('sortSelector').addEventListener('change', handleSelectorsChange);
        document.getElementById('viewSelector').addEventListener('change', handleSelectorsChange);
        document.getElementById('serverSelector').addEventListener('change', handleSelectorsChange);

        // Function to build the grid
        function buildSmallGrid(maps) {
          const gridContainer = document.getElementById('gridContainer');

          // Check if showNSFW cookie is true
          const showNSFW = getCookie('showNSFW');

          // Build grid
          maps.forEach(map => {
            const card = document.createElement('div');
            card.className = `mb-3 mx-auto`;
            card.innerHTML = `
              <div class="mb-3 mx-auto ${showNSFW === 'true' ? '' : (map.nsfw ? 'nsfw' : '')}">
                <div class="image-wrapper">
                  <a href="/mapid/id/${map.id}" class="image-link">
                    <img src="/public/uploads/${map.imgUrl}" class="pixelated-image ${showNSFW === 'true' ? '' : (map.nsfw ? '' : 'blurred')}" alt="Map Image">
                  </a>
                </div>
              </div>
            `;
            // only show nsfw if user is logged in
            if(getCookie('token'); || !map.nsfw){
              gridContainer.appendChild(card);
            }
          });
        };

        // Function to build the grid
        function buildGrid(maps) {
          const gridContainer = document.getElementById('gridContainer');

          // Check if showNSFW cookie is true
          const showNSFW = getCookie('showNSFW');

          // Build grid
          maps.forEach(map => {
            const card = document.createElement('div');
            card.className = `mb-3 mx-auto`;
            card.style = 'width: 18rem;';
            card.innerHTML = `
              <div class="card mb-3 mx-auto ${showNSFW === 'true' ? '' : (map.nsfw ? 'nsfw' : '')}">
                <div class="image-wrapper">
                  <img src="/public/uploads/${map.imgUrl}" class="pixelated-image ${(map.nsfw && showNSFW !== 'true') ? 'blurred' : ''}" alt="Map Image">
                </div>
                <div class="card-body">
                  <h5 class="card-title">${map.displayName}</h5>
                </div>
                <ul class="list-group list-group-flush">
                  <li class="list-group-item">Artist: <a href="/search?query=${map.artist}">${map.artist}</a></li>
                  <li class="list-group-item">Uploaded by: <a href="/profile/user/${map.username}">${map.username}</a></li>
                </ul>
                <div class="card-body">
                  <a href="/mapid/id/${map.id}" class="card-link">View Map</a>
                </div>
              </div>
            `;
            // only show nsfw if user is logged in
            if(getCookie('token'); || !map.nsfw){
              gridContainer.appendChild(card);
            }
          });
        }

        // Function to get cookie value by name
        function getCookie(name) {
          const cookies = document.cookie.split(';');
          for (let cookie of cookies) {
            const [cookieName, cookieValue] = cookie.split('=');
            if (cookieName.trim() === name) {
              return cookieValue;
            }
          }
          return '';
        }

        // Lazy loading
        let observer;
        let currentPage = 1;
        let user = "";
        let artist = "";
        let server = "";
        let sort = "dateDesc";

        function startObservingIntersection() {
          observer = new IntersectionObserver(entries => {
            if (entries[0].isIntersecting) {
              fetchNextPage();
            }
          }, {
            root: null,
            rootMargin: '0px',
            threshold: 1.0
          });

          const lastGridElement = document.getElementById('gridContainer').lastElementChild;
          observer.observe(lastGridElement);
        }

        async function fetchNextPage() {
          currentPage++;
          user = document.getElementById('userSelector').value;
          artist = document.getElementById('artistSelector').value;
          sort = document.getElementById('sortSelector').value;
          view = document.getElementById('viewSelector').value;
          server = document.getElementById('serverSelector').value;
          const lastGridElement = document.getElementById('gridContainer').lastElementChild;
          observer.unobserve(lastGridElement);
          fetchMaps(currentPage, user, artist, sort, view, server);
        }

        // Call the function to populate selectors and fetch initial data when the page loads
        document.addEventListener('DOMContentLoaded', () => {
          $('select').selectpicker();
          populateUserSelector();
          populateArtistSelector();
          populateSortSelector();
          populateServerSelector();
          // Initial API call on page load
          fetchMaps();
        });

      // Grid container for images
      div#gridContainer.row.mb-4

      // Keep loadingSpinner at bottom of page
      script.
        function createLoadingSpinner() {
          const loadingSpinner = document.createElement('div');
          loadingSpinner.id = 'loadingSpinner';
          loadingSpinner.className = 'text-center mt-4';
          
          const spinnerIcon = document.createElement('i');
          spinnerIcon.className = 'fa fa-spinner fa-spin fa-3x';
          
          const loadingText = document.createElement('p');
          loadingText.textContent = 'Loading...';
          
          loadingSpinner.appendChild(spinnerIcon);
          loadingSpinner.appendChild(loadingText);
          
          return loadingSpinner;
        }

        const container = document.querySelector('.container');
        const loadingSpinner = createLoadingSpinner();
        container.appendChild(loadingSpinner);

        // Function to toggle visibility of selectors
        function toggleSelectors() {
          const selectorsForm = document.getElementById('selectorsForm');
          const button = document.getElementById('toggleSelectorsButton');
          if (selectorsForm.style.display === 'none') {
            selectorsForm.style.display = 'block';
            button.textContent = 'Hide Filtering and Sorting';
          } else {
            selectorsForm.style.display = 'none';
            button.textContent = 'Show Filtering and Sorting';
          }
        }

        // Attach event listener to the button
        document.getElementById('toggleSelectorsButton').addEventListener('click', toggleSelectors);

      style.
        .pixelated-image {
          image-rendering: pixelated;
        };

      include includes/scripts.pug